# Values for Kubernetes
ahoy:
  host: ahoy.k8s.host
  clusterType: kubernetes

  auth:
    clientId: ahoy
    redirectUri: http://ahoy.k8s.host/
    issuer: https://keycloak.k8s.host/auth/realms/Ahoy
    jwkSetUri: http://ahoy-keycloak-http.ahoy.svc/auth/realms/Ahoy/protocol/openid-connect/certs
    accountUri: https://keycloak.k8s.host/auth/realms/Ahoy/account/?referrer=ahoy

postgresql:
  ## PostgreSQL user (has superuser privileges if username is `postgres`)
  ## ref: https://github.com/bitnami/bitnami-docker-postgresql/blob/master/README.md#setting-the-root-password-on-first-run
  postgresqlUsername: postgres

  ## PostgreSQL password
  ## ref: https://github.com/bitnami/bitnami-docker-postgresql/blob/master/README.md#setting-the-root-password-on-first-run
  ##
  postgresqlPassword: ahoy123456

  ## Create a database
  ## ref: https://github.com/bitnami/bitnami-docker-postgresql/blob/master/README.md#creating-a-database-on-first-run
  ##
  postgresqlDatabase: ahoy

keycloak:
  install: true

  # Additional environment variables for Keycloak
  extraEnv: |
    - name: KEYCLOAK_IMPORT
      value: /tmp/ahoy/ahoy-realm.json
    - name: KEYCLOAK_USER
      value: admin
    - name: KEYCLOAK_PASSWORD
      value: admin
    - name: PROXY_ADDRESS_FORWARDING
      value: "true"

  # Add additional volumes, e. g. for custom themes
  extraVolumes: |
    - name: ahoy-realm
      configMap:
        name: ahoy-keycloak-realm

  # Add additional volumes mounts, e. g. for custom themes
  extraVolumeMounts: |
    - name: ahoy-realm
      mountPath: "/tmp/ahoy"

  service:
    # The Service type
    type: NodePort

  ingress:
    # If `true`, an Ingress is created
    enabled: true
    # The Service port targeted by the Ingress
    servicePort: http
    # Ingress annotations
    annotations: {}
    # Additional Ingress labels
    labels: {}
    # List of rules for the Ingress
    rules:
      -
        # Ingress host
        host: 'keycloak.k8s.host'
        # Paths for the host
        paths:
          - path: /
            pathType: Prefix
    # TLS configuration
    tls:
      - hosts:
          - keycloak.k8s.host
        secretName: keycloak-tls

  postgresql:
    fullnameOverride: keycloak-postgresql

    # If `true`, the Postgresql dependency is enabled
    enabled: true
    # PostgreSQL User to create
    postgresqlUsername: keycloak
    # PostgreSQL Password for the new user
    postgresqlPassword: keycloak
    # PostgreSQL Database to create
    postgresqlDatabase: keycloak
    # Persistent Volume Storage configuration

argo-cd:
  install: true

  ## ArgoCD configuration
  ## Ref: https://github.com/argoproj/argo-cd
  ##
  nameOverride: argocd
  fullnameOverride: ""
  kubeVersionOverride: ""

  server:
    extraArgs:
      - --insecure

    ingress:
      enabled: true
      annotations:
        kubernetes.io/ingress.class: nginx
        nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
        nginx.ingress.kubernetes.io/ssl-passthrough: "true"
        nginx.ingress.kubernetes.io/proxy-connect-timeout: "3600"
        nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
        nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"

      labels: { }
      ingressClassName: ""

      hosts:
        - argocd.k8s.host
      paths:
        [ ]
      extraPaths:
        - path: /
          pathType: Prefix
          backend:
            service:
              name: ahoy-argocd-server
              port:
                number: 443
      tls:
        [ ]
      https: false

    config:
      accounts.ahoy: apiKey,login

    rbacConfig:
      policy.csv: g, ahoy, role:admin

sealed-secrets:
  install: true

  image:
    repository: quay.io/bitnami/sealed-secrets-controller
    tag: v0.16.0
    pullPolicy: IfNotPresent
    pullSecret: ""

  resources: { }
  nodeSelector: { }
  tolerations: [ ]
  affinity: { }

  controller:
    # controller.create: `true` if Sealed Secrets controller should be created
    create: true
    # controller.labels: Extra labels to be added to controller deployment
    labels: {}
    # controller.service: Configuration options for controller service
    service:
      # controller.service.labels: Extra labels to be added to controller service
      labels: {}

  # namespace: Namespace to deploy the controller.
  namespace: ""

  serviceAccount:
    # serviceAccount.create: Whether to create a service account or not
    create: true
    # serviceAccount.labels: Extra labels to be added to service account
    labels: {}
    # serviceAccount.name: The name of the service account to create or use
    name: ""

  rbac:
    # rbac.create: `true` if rbac resources should be created
    create: true
    # rbac.labels: Extra labels to be added to rbac resources
    labels: {}
    pspEnabled: false

  # secretName: The name of the TLS secret containing the key used to encrypt secrets
  secretName: "sealed-secrets-key"

  ingress:
    enabled: false
    annotations: { }
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
    path: /v1/cert.pem
    hosts:
      - chart-example.local
    tls: [ ]
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local

  crd:
    # crd.create: `true` if the crd resources should be created
    create: true
    # crd.keep: `true` if the sealed secret CRD should be kept when the chart is deleted
    keep: true

  networkPolicy: false

  securityContext:
    # securityContext.runAsUser defines under which user the operator Pod and its containers/processes run.
    runAsUser: 1001
    # securityContext.fsGroup defines the filesystem group
    fsGroup: 65534

  podAnnotations: { }

  podLabels: { }

  priorityClassName: ""

  serviceMonitor:
    # Enables ServiceMonitor creation for the Prometheus Operator
    create: false
    # How frequently Prometheus should scrape the ServiceMonitor
    interval:
    # Extra labels to apply to the sealed-secrets ServiceMonitor
    labels:
    # The namespace where the ServiceMonitor is deployed, defaults to the installation namespace
    namespace:
    # The timeout after which the scrape is ended
    scrapeTimeout:

  dashboards:
    # If enabled, sealed-secrets will create a configmap with a dashboard in json that's going to be picked up by grafana
    # See https://github.com/helm/charts/tree/master/stable/grafana#configuration - `sidecar.dashboards.enabled`
    create: false
    # Extra labels to apply to the dashboard configmaps
    labels:
    # The namespace where the dashboards are deployed, defaults to the installation namespace
    namespace:
